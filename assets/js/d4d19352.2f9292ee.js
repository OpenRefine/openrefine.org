"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[184],{48333:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var s=n(64861),r=n(69018);const i={id:"exploring",title:"Exploring data",sidebar_label:"Overview"},o=void 0,a={id:"manual/exploring",title:"Exploring data",description:"Overview",source:"@site/docs/manual/exploring.md",sourceDirName:"manual",slug:"/manual/exploring",permalink:"/docs/manual/exploring",draft:!1,unlisted:!1,editUrl:"https://github.com/OpenRefine/openrefine.github.com/edit/master/docs/manual/exploring.md",tags:[],version:"current",lastUpdatedBy:"Antonin Delpeuch",lastUpdatedAt:1677509288e3,frontMatter:{id:"exploring",title:"Exploring data",sidebar_label:"Overview"},sidebar:"docs",previous:{title:"Starting a project",permalink:"/docs/manual/starting"},next:{title:"Facets",permalink:"/docs/manual/facets"}},l={},d=[{value:"Overview",id:"overview",level:2},{value:"Data types",id:"data-types",level:2},{value:"Dates",id:"dates",level:3},{value:"Rows vs. records",id:"rows-vs-records",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"OpenRefine offers lots of features to help you learn about your dataset, even if you don\u2019t change a single character. In this section we cover different ways for sorting through, filtering, and viewing your data."}),"\n",(0,s.jsx)(t.p,{children:"Unlike spreadsheets, OpenRefine doesn\u2019t store formulas and display the output of those calculations; it only shows the value inside each cell. It doesn\u2019t support cell colors or text formatting."}),"\n",(0,s.jsx)(t.h2,{id:"data-types",children:"Data types"}),"\n",(0,s.jsx)(t.p,{children:"Each piece of information (each cell) in OpenRefine is assigned a data type. Some file formats, when imported, can set data types that are recognized by OpenRefine. Cells without an associated data type on import will be considered a \u201cstring\u201d at first, but you can have OpenRefine convert cell contents into other data types later. This is set at the cell level, not at the column level."}),"\n",(0,s.jsxs)(t.p,{children:["You can see data types in action when you preview a new project: check the box next to ",(0,s.jsx)("span",{class:"fieldLabels",children:"Attempt to parse cell text into numbers"}),", and cells will be converted to the \u201cnumber\u201d data type based on their contents. You\u2019ll see numbers change from black text to green if they are recognized."]}),"\n",(0,s.jsx)(t.p,{children:"The data type will determine what you can do with the value. For example, if you want to add two values together, they must both be recognized as the number type."}),"\n",(0,s.jsx)(t.p,{children:"You can check data types at any time by:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"clicking \u201cedit\u201d on a single cell (where you can also edit the type)"}),"\n",(0,s.jsxs)(t.li,{children:["creating a ",(0,s.jsx)("span",{class:"menuItems",children:"Custom Text Facet"})," on a column, and inserting ",(0,s.jsx)(t.code,{children:"type(value)"})," into the ",(0,s.jsx)("span",{class:"fieldLabels",children:"Expression"})," field. This will generate the data type in the preview, and you can facet by data type if you press ",(0,s.jsx)("span",{class:"buttonLabels",children:"OK"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The data types supported are:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"string (one or more text characters)"}),"\n",(0,s.jsx)(t.li,{children:"number (one or more characters of numbers only)"}),"\n",(0,s.jsx)(t.li,{children:"boolean (values of \u201ctrue\u201d or \u201cfalse\u201d)"}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"#dates",children:"date"})," (ISO-8601-compliant extended format with time in UTC: YYYY-MM-DDTHH:MM",":SSZ",")"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"OpenRefine recognizes two further data types as a result of its own processes:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"error"}),"\n",(0,s.jsx)(t.li,{children:"null"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"An \u201cerror\u201d data type is created when the cell is storing an error generated during a transformation in OpenRefine."}),"\n",(0,s.jsxs)(t.p,{children:["A \u201cnull\u201d data type is a special type that means \u201cthis cell has no value.\u201d It\u2019s distinct from cells that have values such as \u201c0\u201d or \u201cfalse\u201d, or cells that look empty but have whitespace in them, or cells that contain empty strings. When you use ",(0,s.jsx)(t.code,{children:"type(value)"}),", it will show you that the cell\u2019s value is \u201cnull\u201d and its type is \u201cundefined.\u201d You can opt to ",(0,s.jsx)(t.a,{href:"sortview#showhide-null",children:"show \u201cnull\u201d values"}),", by going to ",(0,s.jsx)("span",{class:"menuItems",children:"All"})," \u2192 ",(0,s.jsx)("span",{class:"menuItems",children:"View"})," \u2192 ",(0,s.jsx)("span",{class:"menuItems",children:"Show/Hide \u2018null\u2019 values in cells"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Changing a cell's data type is not the same operation as transforming its contents. For example, using a column-wide transform such as ",(0,s.jsx)("span",{class:"menuItems",children:"Transform"})," \u2192 ",(0,s.jsx)("span",{class:"menuItems",children:"Common transforms"})," \u2192 ",(0,s.jsx)("span",{class:"menuItems",children:"To date"})," may not convert all values successfully, but going to an individual cell, clicking \u201cedit\u201d, and changing the data type can successfully convert text to a date. These operations use different underlying code. Learn more about date formatting and transformations in the next section."]}),"\n",(0,s.jsxs)(t.p,{children:["To transform data from one type to another, see ",(0,s.jsx)(t.a,{href:"cellediting#data-type-transforms",children:"Transforming data"})," for information on using common tranforms, and see ",(0,s.jsx)(t.a,{href:"expressions",children:"Expressions"})," for information on using ",(0,s.jsx)(t.a,{href:"grelfunctions#tostringo-string-format-optional",children:"toString()"}),", ",(0,s.jsx)(t.a,{href:"grelfunctions#todateo-b-monthfirst-s-format1-s-format2-",children:"toDate()"}),", and other functions."]}),"\n",(0,s.jsx)(t.h3,{id:"dates",children:"Dates"}),"\n",(0,s.jsxs)(t.p,{children:["A \u201cdate\u201d type is created when a column is ",(0,s.jsx)(t.a,{href:"transforming#to-date",children:"transformed into dates"}),", when an expression is used to ",(0,s.jsx)(t.a,{href:"grelfunctions#todateo-b-monthfirst-s-format1-s-format2-",children:"convert cells to dates"})," or when individual cells are set to have the data type \u201cdate\u201d."]}),"\n",(0,s.jsxs)(t.p,{children:["Date-formatted data in OpenRefine relies on a number of conversion tools and standards. For something to be considered a date in OpenRefine, it will be converted into the ISO-8601-compliant extended format with time in UTC: YYYY-MM-DDTHH:MM",":SSZ","."]}),"\n",(0,s.jsxs)(t.p,{children:["When you run ",(0,s.jsx)("span",{class:"menuItems",children:"Edit cells"})," \u2192 ",(0,s.jsx)("span",{class:"menuItems",children:"Common transforms"})," \u2192 ",(0,s.jsx)("span",{class:"menuItems",children:"To date"}),", the following column of strings on the left will transform into the values on the right:"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Input"}),(0,s.jsx)(t.th,{children:"\u2192"}),(0,s.jsx)(t.th,{children:"Output"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"23/12/2019"}),(0,s.jsx)(t.td,{children:"\u2192"}),(0,s.jsx)(t.td,{children:"2019-12-23T00:00:00Z"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"14-10-2015"}),(0,s.jsx)(t.td,{children:"\u2192"}),(0,s.jsx)(t.td,{children:"2015-10-14T00:00:00Z"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"2012 02 16"}),(0,s.jsx)(t.td,{children:"\u2192"}),(0,s.jsx)(t.td,{children:"2012-02-16T00:00:00Z"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"August 2nd 1964"}),(0,s.jsx)(t.td,{children:"\u2192"}),(0,s.jsx)(t.td,{children:"1964-08-02T00:00:00Z"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"today"}),(0,s.jsx)(t.td,{children:"\u2192"}),(0,s.jsx)(t.td,{children:"today"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"never"}),(0,s.jsx)(t.td,{children:"\u2192"}),(0,s.jsx)(t.td,{children:"never"})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["OpenRefine uses a variety of tools to recognize, convert, and format ",(0,s.jsx)(t.a,{href:"exploring#dates",children:"dates"})," and so some of the values above can be reformatted using other methods. In this case, clicking the \u201ctoday\u201d cell and editing its data type manually will convert \u201ctoday\u201d into a value such as \u201c2020-08-14T00:00:00Z\u201d. Attempting the same data-type change on \u201cnever\u201d will give you an error message and refuse to proceed."]}),"\n",(0,s.jsxs)(t.p,{children:["You can do more precise conversion and formatting using expressions and arguments based on the state of your data: see the GREL functions reference section on ",(0,s.jsx)(t.a,{href:"grelfunctions#date-functions",children:"Date functions"})," for more help."]}),"\n",(0,s.jsxs)(t.p,{children:["You can convert dates into a more human-readable format when you ",(0,s.jsx)(t.a,{href:"exporting#custom-tabular-exporter",children:"export your data using the custom tabular exporter"}),". You are given the option to keep your dates in the ISO 8601 format, to output short, medium, long, or full locale formats, or to specify a custom format. This means that you can format your dates into, for example, MM/DD/YY (the US short standard) with or without including the time, after working with ISO-8601-formatted dates in your project."]}),"\n",(0,s.jsxs)(t.p,{children:["The following table shows some example ",(0,s.jsx)(t.a,{href:"https://docs.oracle.com/javase/tutorial/i18n/format/dateFormat.html",children:"date and time formatting styles for the U.S. and French locales"}),":"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Style"}),(0,s.jsx)(t.th,{children:"U.S. Locale"}),(0,s.jsx)(t.th,{children:"French Locale"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Default"}),(0,s.jsx)(t.td,{children:"Jun 30, 2009 7:03:47 AM"}),(0,s.jsx)(t.td,{children:"30 juin 2009 07:03:47"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Short"}),(0,s.jsx)(t.td,{children:"6/30/09 7:03 AM"}),(0,s.jsx)(t.td,{children:"30/06/09 07:03"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Medium"}),(0,s.jsx)(t.td,{children:"Jun 30, 2009 7:03:47 AM"}),(0,s.jsx)(t.td,{children:"30 juin 2009 07:03:47"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Long"}),(0,s.jsx)(t.td,{children:"June 30, 2009 7:03:47 AM PDT"}),(0,s.jsx)(t.td,{children:"30 juin 2009 07:03:47 PDT"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Full"}),(0,s.jsx)(t.td,{children:"Tuesday, June 30, 2009 7:03:47 AM PDT"}),(0,s.jsx)(t.td,{children:"mardi 30 juin 2009 07 h 03 PDT"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"rows-vs-records",children:"Rows vs. records"}),"\n",(0,s.jsx)(t.p,{children:"A row is a simple way to organize data: a series of cells, one cell per column. Sometimes there are multiple pieces of information in one cell, such as when a survey respondent can select more than one response."}),"\n",(0,s.jsx)(t.p,{children:"In cases where there is more than one value for a single column in one or more rows, you may wish to use OpenRefine\u2019s records mode: this defines a single record as potentially containing more than one row. From there you can transform cells into multiple rows, each cell containing one value you\u2019d like to work with."}),"\n",(0,s.jsx)(t.p,{children:"Generally, when you import some data, OpenRefine reads that data in row mode. From the project screen, you can convert the project into records mode. OpenRefine remembers this action and will present you with records mode each time you open the project from then on."}),"\n",(0,s.jsx)(t.p,{children:"OpenRefine understands records based on the content of the first column, what we call the \u201ckey column.\u201d Splitting a row into a multi-row record will base all association on the first column in your dataset."}),"\n",(0,s.jsx)(t.p,{children:"If you have more than one column to split out into multiple rows, OpenRefine will keep your data associated with its original record, and associate subgroups based on the top-most row in each group."}),"\n",(0,s.jsx)(t.p,{children:"You can imagine the structure as a tree with many branches, all leading back to the same trunk."}),"\n",(0,s.jsx)(t.p,{children:"For example, your key column may be a film or television show, with multiple cast members identified by name, associated to that work. You may have one or more roles listed for each person. The roles are linked to the actors, which are linked to the title."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Work"}),(0,s.jsx)(t.th,{children:"Actor"}),(0,s.jsx)(t.th,{children:"Role"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"The Wizard of Oz"}),(0,s.jsx)(t.td,{children:"Judy Garland"}),(0,s.jsx)(t.td,{children:"Dorothy Gale"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"Ray Bolger"}),(0,s.jsx)(t.td,{children:'"Hunk"'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Scarecrow"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"Jack Haley"}),(0,s.jsx)(t.td,{children:'"Hickory"'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Tin Man"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"Bert Lahr"}),(0,s.jsx)(t.td,{children:'"Zeke"'})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Cowardly Lion"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"Frank Morgan"}),(0,s.jsx)(t.td,{children:"Professor Marvel"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Gatekeeper"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Carriage Driver"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Guard"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Wizard of Oz"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"Margaret Hamilton"}),(0,s.jsx)(t.td,{children:"Miss Almira Gulch"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{}),(0,s.jsx)(t.td,{children:"The Wicked Witch of the West"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"Once you are in records mode, you can still move some columns around, but if you move a column to the beginning, you may find your data becomes misaligned. The new key column will sort into records based on empty cells, and values in the old key column will be assigned to the last row in the old record (the key value sitting above those values)."}),"\n",(0,s.jsxs)(t.p,{children:["OpenRefine assigns a unique key behind the scenes, so your records don\u2019t need a unique identifier in the key column. You can keep track of which rows are assigned to each record by the record number that appears under the ",(0,s.jsx)("span",{class:"menuItems",children:"All"})," column."]}),"\n",(0,s.jsxs)(t.p,{children:["To ",(0,s.jsx)(t.a,{href:"transforming#split-multi-valued-cells",children:"split multi-valued cells"})," and apply other operations that take advantage of records mode, see ",(0,s.jsx)(t.a,{href:"transforming",children:"Transforming data"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Be careful when in records mode that you do not accidentally delete rows based on being blank in one column where there is a value in another."}),"\n",(0,s.jsxs)(t.p,{children:["This feature is related to ",(0,s.jsx)(t.a,{href:"../technical-reference/architecture-before-4#column-groups",children:"Column Groups"}),", which however is incomplete and deprecated."]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},69018:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>o});var s=n(47768);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);