"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[857],{80602:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var s=t(64861),r=t(69018);const i={id:"grel",title:"General Refine Expression Language",sidebar_label:"General Refine Expression Language"},l=void 0,a={id:"manual/grel",title:"General Refine Expression Language",description:"Basics",source:"@site/docs/manual/grel.md",sourceDirName:"manual",slug:"/manual/grel",permalink:"/docs/manual/grel",draft:!1,unlisted:!1,editUrl:"https://github.com/OpenRefine/openrefine.github.com/edit/master/docs/manual/grel.md",tags:[],version:"current",lastUpdatedBy:"Aayush",lastUpdatedAt:1707745677e3,frontMatter:{id:"grel",title:"General Refine Expression Language",sidebar_label:"General Refine Expression Language"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/manual/expressions"},next:{title:"GREL functions",permalink:"/docs/manual/grelfunctions"}},o={},d=[{value:"Basics",id:"basics",level:2},{value:"Operators",id:"operators",level:2},{value:"Arithmetic Operators",id:"arithmetic-operators",level:4},{value:"Modulus",id:"modulus",level:6},{value:"Multiplication",id:"multiplication",level:6},{value:"Relational Operators",id:"relational-operators",level:4},{value:"References",id:"references",level:4},{value:"Syntax",id:"syntax",level:2},{value:"Controls",id:"controls",level:2},{value:"if(e, eTrue, eFalse)",id:"ife-etrue-efalse",level:4},{value:"with(e1, variable v, e2)",id:"withe1-variable-v-e2",level:4},{value:"filter(e1, v, e test)",id:"filtere1-v-e-test",level:4},{value:"forEach(e1, v, e2)",id:"foreache1-v-e2",level:4},{value:"forEachIndex(e1, i, v, e2)",id:"foreachindexe1-i-v-e2",level:4},{value:"forRange(n from, n to, n step, v, e)",id:"forrangen-from-n-to-n-step-v-e",level:4},{value:"forNonBlank(e, v, eNonBlank, eBlank)",id:"fornonblanke-v-enonblank-eblank",level:4},{value:"isBlank(e), isNonBlank(e), isNull(e), isNotNull(e), isNumeric(e), isError(e)",id:"isblanke-isnonblanke-isnulle-isnotnulle-isnumerice-iserrore",level:4},{value:"Constants",id:"constants",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h4:"h4",h6:"h6",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"basics",children:"Basics"}),"\n",(0,s.jsx)(n.p,{children:"GREL (General Refine Expression Language) is designed to resemble Javascript. Formulas use variables and depend on data types to do things like string manipulation or mathematical calculations:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"Output"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'value + " (approved)"'})}),(0,s.jsx)(n.td,{children:"Concatenate two strings; whatever is in the cell gets converted to a string first"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value + 2.239"})}),(0,s.jsx)(n.td,{children:'Add 2.239 to the existing value (if a number); append text "2.239" to the end of the string otherwise'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"value.trim().length()"})," \xa0 \xa0"]}),(0,s.jsx)(n.td,{children:"Trim leading and trailing whitespace of the cell value and then output the length of the result"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value.substring(7, 10)"})}),(0,s.jsx)(n.td,{children:"Output the substring of the value from character index 7, 8, and 9 (excluding character index 10)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value.substring(13)"})}),(0,s.jsx)(n.td,{children:"Output the substring from index 13 to the end of the string"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the operator for string concatenation is ",(0,s.jsx)(n.code,{children:"+"})," (not \u201c&\u201d as is used in Excel)."]}),"\n",(0,s.jsxs)(n.p,{children:["Evaluating conditions uses symbols such as ",(0,s.jsx)(n.code,{children:"<"}),", ",(0,s.jsx)(n.code,{children:">"}),", ",(0,s.jsx)(n.code,{children:"*"}),", ",(0,s.jsx)(n.code,{children:"/"}),", etc. To check whether two objects are equal, use two equal signs (",(0,s.jsx)(n.code,{children:'value=="true"'}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.a,{href:"grelfunctions",children:"GREL functions page for a thorough reference"})," on each function and its inputs and outputs. Read on below for more about the general nature of GREL expressions."]}),"\n",(0,s.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,s.jsx)(n.h4,{id:"arithmetic-operators",children:"Arithmetic Operators"}),"\n",(0,s.jsxs)(n.p,{children:["Refer ",(0,s.jsx)(n.a,{href:"https://openrefine.org/docs/manual/grelfunctions#math-functions",children:"GREL functions page"})," for details on Division Operator."]}),"\n",(0,s.jsx)(n.h6,{id:"modulus",children:"Modulus"}),"\n",(0,s.jsxs)(n.p,{children:["When using the ",(0,s.jsx)(n.code,{children:"%"})," operator, if both operands are numbers such as ",(0,s.jsx)(n.code,{children:"1 % 2"})," the result will be a whole number. However, if either or both of the operands are floating-point numbers like ",(0,s.jsx)(n.code,{children:"1.0 % 2"})," they will be promoted to floating point and the result will also be in floating-point format. It's important to note that the ",(0,s.jsx)(n.code,{children:"%"})," operator may not behave as expected with floating-point numbers due to precision issues."]}),"\n",(0,s.jsx)(n.h6,{id:"multiplication",children:"Multiplication"}),"\n",(0,s.jsxs)(n.p,{children:["The behavior of the ",(0,s.jsx)(n.code,{children:"*"})," operator is nuanced based on the data types of the operands. When both operands are integers such as ",(0,s.jsx)(n.code,{children:"1 * 2"}),", the result is an integer. Conversely, if either or both operands are floating-point numbers the result becomes a floating-point number. You can use simple evaluations such as ",(0,s.jsx)(n.code,{children:"3.5 * 2"})]}),"\n",(0,s.jsx)(n.h4,{id:"relational-operators",children:"Relational Operators"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"=="})," and ",(0,s.jsx)(n.code,{children:"!="})," operators are used to assess equality and inequality. For instance, ",(0,s.jsx)(n.code,{children:'"a" == "b"'})," returns false and ",(0,s.jsx)(n.code,{children:'"a" != "b"'})," returns true. When applied to integers, ",(0,s.jsx)(n.code,{children:"5 == 5"})," returns true, while ",(0,s.jsx)(n.code,{children:"3 != 3"})," returns false."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<"})," operator checks if the left operand is less than the right operand, while ",(0,s.jsx)(n.code,{children:"<="})," checks if it's less than or equal to. Similarly ",(0,s.jsx)(n.code,{children:">"})," verifies if the left operand is greater than the right and ",(0,s.jsx)(n.code,{children:">="})," checks if it's greater than or equal to. These comparison operators apply to numbers, strings and dates."]}),"\n",(0,s.jsx)(n.h4,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://openrefine.org/docs/manual/grel#basic",children:"String Concatenation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://openrefine.org/docs/manual/grelfunctions#boolean-functions",children:"Logical Functions"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.p,{children:"In GREL, functions can use either of these two forms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"functionName(arg0, arg1, ...)"}),"\n",(0,s.jsx)(n.li,{children:"arg0.functionName(arg1, ...)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The second form is a shorthand to make expressions easier to read. It simply pulls the first argument out and appends it to the front of the function, with a dot:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Dot notation"}),(0,s.jsx)(n.th,{children:"Full notation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value.trim().length()"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"length(trim(value))"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value.substring(7, 10)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"substring(value, 7, 10)"})})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"So, in the dot shorthand, the functions occur from left to right in the order of calling, rather than in the reverse order with parentheses. This allows you to string together multiple functions in a readable order."}),"\n",(0,s.jsxs)(n.p,{children:["The dot notation can also be used to access the member fields of ",(0,s.jsx)(n.a,{href:"expressions#variables",children:"variables"}),". For referring to column names that contain spaces (anything not a continuous string), use square brackets instead of dot notation:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"FirstName.cells"})}),(0,s.jsx)(n.td,{children:"Access the cell in the column named \u201cFirstName\u201d of the current row"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'cells["First Name"]'})}),(0,s.jsx)(n.td,{children:"Access the cell in the column called \u201cFirst Name\u201d of the current row"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Square brackets can also be used to get substrings and sub-arrays, and single items from arrays:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Example"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"value[1,3]"})}),(0,s.jsx)(n.td,{children:"A substring of value, starting from character 1 up to but excluding character 3"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"internationalization"[1,-2]'})}),(0,s.jsx)(n.td,{children:"Will return \u201cnternationalizati\u201d (negative indexes are counted from the end)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"row.columnNames[5]"})}),(0,s.jsx)(n.td,{children:"Will return the name of the fifth column"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Any function that outputs an array can use square brackets to select only one part of the array to output as a string (remember that the index of the items in an array starts with 0)."}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.a,{href:"grelfunctions#partitions-s-or-p-fragment-b-omitfragment-optional",children:"partition()"})," would normally output an array of three items: the part before your chosen fragment, the fragment you've identified, and the part after. Selecting only the third part with ",(0,s.jsx)(n.code,{children:'"internationalization".partition("nation")[2]'})," will output \u201calization\u201d (and so will [-1], indicating the final item in the array)."]}),"\n",(0,s.jsx)(n.h2,{id:"controls",children:"Controls"}),"\n",(0,s.jsxs)(n.p,{children:["GREL offers controls to support branching and looping (that is, \u201cif\u201d and \u201cfor\u201d functions), but unlike functions, their arguments don't all get evaluated before they get run. A control can decide which part of the code to execute and can affect the environment bindings. Functions, on the other hand, can't do either. Each control decides which of their arguments to evaluate to ",(0,s.jsx)(n.code,{children:"value"}),", and how."]}),"\n",(0,s.jsx)(n.p,{children:"Please note that the GREL control names are case-sensitive: for example, the isError() control can't be called with iserror()."}),"\n",(0,s.jsx)(n.h4,{id:"ife-etrue-efalse",children:"if(e, eTrue, eFalse)"}),"\n",(0,s.jsx)(n.p,{children:"Expression e is evaluated to a value. If that value is true, then expression eTrue is evaluated and the result is the value of the whole if() expression. Otherwise, expression eFalse is evaluated and that result is the value."}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Example expression"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'if("internationalization".length() > 10, "big string", "small string")'})}),(0,s.jsx)(n.td,{children:"\u201cbig string\u201d"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'if(mod(37, 2) == 0, "even", "odd")'})}),(0,s.jsx)(n.td,{children:"\u201codd\u201d"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Nested if (switch case) example:"}),"\n",(0,s.jsxs)(n.p,{children:["if(value == 'Place', '",(0,s.jsx)(n.a,{href:"http://www.example.com/Location",children:"http://www.example.com/Location"}),"',"]}),"\n",(0,s.jsxs)(n.p,{children:["if(value == 'Person', '",(0,s.jsx)(n.a,{href:"http://www.example.com/Agent",children:"http://www.example.com/Agent"}),"',"]}),"\n",(0,s.jsxs)(n.p,{children:["if(value == 'Book', '",(0,s.jsx)(n.a,{href:"http://www.example.com/Publication",children:"http://www.example.com/Publication"}),"',"]}),"\n",(0,s.jsx)(n.p,{children:"null)))"}),"\n",(0,s.jsx)(n.h4,{id:"withe1-variable-v-e2",children:"with(e1, variable v, e2)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates expression e1 and binds its value to variable v. Then evaluates expression e2 and returns that result."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Example expression"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'with("european union".split(" "), a, a.length())'})}),(0,s.jsx)(n.td,{children:"2"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'with("european union".split(" "), a, forEach(a, v, v.length()))'})}),(0,s.jsx)(n.td,{children:"[ 8, 5 ]"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'with("european union".split(" "), a, forEach(a, v, v.length()).sum() / a.length())'})}),(0,s.jsx)(n.td,{children:"6.5"})]})]})]}),"\n",(0,s.jsx)(n.h4,{id:"filtere1-v-e-test",children:"filter(e1, v, e test)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates expression e1 to an array. Then for each array element, binds its value to variable v, evaluates expression test - which should return a boolean. If the boolean is true, pushes v onto the result array."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"filter([ 3, 4, 8, 7, 9 ], v, mod(v, 2) == 1)"})}),(0,s.jsx)(n.td,{children:"[ 3, 7, 9 ]"})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"foreache1-v-e2",children:"forEach(e1, v, e2)"}),"\n",(0,s.jsxs)(n.p,{children:["Evaluates expression e1 to an array. Then for each array element, binds its value to variable v, evaluates expression e2, and pushes the result onto the result array. When e1 is a JSON object, ",(0,s.jsx)(n.code,{children:"forEach"})," iterates over its keys."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"forEach([ 3, 4, 8, 7, 9 ], v, mod(v, 2))"})}),(0,s.jsx)(n.td,{children:"[ 1, 0, 0, 1, 1 ]"})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"foreachindexe1-i-v-e2",children:"forEachIndex(e1, i, v, e2)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates expression e1 to an array. Then for each array element, binds its index to variable i and its value to variable v, evaluates expression e2, and pushes the result onto the result array."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'forEachIndex([ "anne", "ben", "cindy" ], i, v, (i + 1) + ". " + v).join(", ")'})}),(0,s.jsx)(n.td,{children:"1. anne, 2. ben, 3. cindy"})]})})]}),"\n",(0,s.jsx)(n.h4,{id:"forrangen-from-n-to-n-step-v-e",children:"forRange(n from, n to, n step, v, e)"}),"\n",(0,s.jsx)(n.p,{children:"Iterates over the variable v starting at from, incrementing by the value of step each time while less than to. At each iteration, evaluates expression e, and pushes the result onto the result array."}),"\n",(0,s.jsx)(n.h4,{id:"fornonblanke-v-enonblank-eblank",children:"forNonBlank(e, v, eNonBlank, eBlank)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates expression e. If it is non-blank, forNonBlank() binds its value to variable v, evaluates expression eNonBlank and returns the result. Otherwise (if e evaluates to blank), forNonBlank() evaluates expression eBlank and returns that result instead."}),"\n",(0,s.jsx)(n.p,{children:"Unlike other GREL functions beginning with \u201cfor,\u201d forNonBlank() is not iterative. forNonBlank() essentially offers a shorter syntax to achieving the same outcome by using the isNonBlank() function within an \u201cif\u201d statement."}),"\n",(0,s.jsx)(n.h4,{id:"isblanke-isnonblanke-isnulle-isnotnulle-isnumerice-iserrore",children:"isBlank(e), isNonBlank(e), isNull(e), isNotNull(e), isNumeric(e), isError(e)"}),"\n",(0,s.jsx)(n.p,{children:"Evaluates the expression e, and returns a boolean based on the named evaluation."}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Expression"}),(0,s.jsx)(n.th,{children:"Result"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'isBlank("abc")'})}),(0,s.jsx)(n.td,{children:"false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'isNonBlank("abc")'})}),(0,s.jsx)(n.td,{children:"true"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'isNull("abc")'})}),(0,s.jsx)(n.td,{children:"false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'isNotNull("abc")'})}),(0,s.jsx)(n.td,{children:"true"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isNumeric(2)"})}),(0,s.jsx)(n.td,{children:"true"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isError(1)"})}),(0,s.jsx)(n.td,{children:"false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'isError("abc")'})}),(0,s.jsx)(n.td,{children:"false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isError(1 / 0)"})}),(0,s.jsx)(n.td,{children:"true"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Remember that these are controls and not functions: you can\u2019t use dot notation (for example, the format ",(0,s.jsx)(n.code,{children:"e.isX()"})," will not work)."]}),"\n",(0,s.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"true"}),(0,s.jsx)(n.td,{children:"The boolean constant true"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"The boolean constant false"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"PI"}),(0,s.jsxs)(n.td,{children:["From ",(0,s.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#PI",children:"Java's Math.PI"}),", the value of pi (that is, 3.1415...)"]})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},69018:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>l});var s=t(47768);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);