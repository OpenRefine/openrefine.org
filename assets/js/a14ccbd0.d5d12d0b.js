"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[2789],{66459:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=n(64861),r=n(69018);const s={id:"architecture-before-4",title:"Architecture before version 4",sidebar_label:"Architecture before version 4"},o=void 0,a={id:"technical-reference/architecture-before-4",title:"Architecture before version 4",description:"OpenRefine is a web application, but is designed to be run locally on your own machine. The server-side maintains states of the data (undo/redo history, long-running processes, etc.) while the client-side maintains states of the user interface (facets and their selections, view pagination, etc.). The client-side makes GET and POST ajax calls to cause changes to the data and to fetch data and data-related states from the server-side.",source:"@site/docs/technical-reference/architecture-before-4.md",sourceDirName:"technical-reference",slug:"/technical-reference/architecture-before-4",permalink:"/docs/technical-reference/architecture-before-4",draft:!1,unlisted:!1,editUrl:"https://github.com/OpenRefine/openrefine.github.com/edit/master/docs/technical-reference/architecture-before-4.md",tags:[],version:"current",lastUpdatedBy:"Antonin Delpeuch",lastUpdatedAt:1677509288e3,frontMatter:{id:"architecture-before-4",title:"Architecture before version 4",sidebar_label:"Architecture before version 4"},sidebar:"docs",previous:{title:"Functional tests",permalink:"/docs/technical-reference/functional-tests"},next:{title:"Architecture in version 4",permalink:"/docs/technical-reference/architecture-4"}},c={},l=[{value:"Technology stack",id:"technology-stack",level:2},{value:"Server-side architecture",id:"server-side-architecture",level:2},{value:"Projects",id:"projects",level:3},{value:"Data Model",id:"data-model",level:3},{value:"Column Model",id:"column-model",level:4},{value:"Column Groups",id:"column-groups",level:5},{value:"Changes, History, Processes, and Operations",id:"changes-history-processes-and-operations",level:3},{value:"Client-side architecture",id:"client-side-architecture",level:2},{value:"Importing architecture",id:"importing-architecture",level:3},{value:"The Index Page and Action Areas",id:"the-index-page-and-action-areas",level:3},{value:"The Create Project Action Area",id:"the-create-project-action-area",level:3},{value:"Importing Controllers",id:"importing-controllers",level:4},{value:"Data Source Selection UIs",id:"data-source-selection-uis",level:4},{value:"File Selection Panel",id:"file-selection-panel",level:4},{value:"Parsing UI Panel",id:"parsing-ui-panel",level:4},{value:"Server-side Components",id:"server-side-components",level:3},{value:"ImportingController",id:"importingcontroller",level:4},{value:"FormatGuesser",id:"formatguesser",level:4},{value:"ImportingParser",id:"importingparser",level:4},{value:"Faceted browsing architecture",id:"faceted-browsing-architecture",level:2},{value:"Engine Configuration",id:"engine-configuration",level:3},{value:"Server-Side Subsystem",id:"server-side-subsystem",level:3},{value:"Client-side subsystem",id:"client-side-subsystem",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"OpenRefine is a web application, but is designed to be run locally on your own machine. The server-side maintains states of the data (undo/redo history, long-running processes, etc.) while the client-side maintains states of the user interface (facets and their selections, view pagination, etc.). The client-side makes GET and POST ajax calls to cause changes to the data and to fetch data and data-related states from the server-side."}),"\n",(0,i.jsx)(t.p,{children:"This architecture provides a good separation of concerns (data vs. UI); allows the use of familiar web technologies (HTML, CSS, Javascript) to implement user interface features; and enables the server side to be called by third-party software through standard GET and POST requests."}),"\n",(0,i.jsx)(t.h2,{id:"technology-stack",children:"Technology stack"}),"\n",(0,i.jsxs)(t.p,{children:["The server-side (back-end) part of OpenRefine is implemented in Java as one single servlet which is executed by the ",(0,i.jsx)(t.a,{href:"http://jetty.codehaus.org/jetty/",children:"Jetty"})," web server and servlet container. The use of Java strikes a balance between performance and portability across operating systems (there is very little OS-specific code and has mostly to do with starting the application)."]}),"\n",(0,i.jsxs)(t.p,{children:["The functional extensibility of OpenRefine is provided by a fork of the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenRefine/simile-butterfly",children:"SIMILE Butterfly"})," modular web application framework. With this framework, extensions are able to provide new functionality both in the\nserver- and client-side. A ",(0,i.jsx)(t.a,{href:"https://openrefine.org/extensions",children:"list of known extensions"})," is maintained on our website and we have ",(0,i.jsx)(t.a,{href:"/docs/technical-reference/writing-extensions",children:"specific documentation for extension developers"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The client-side part of OpenRefine is implemented in HTML, CSS and plain Javascript. It primariy uses the following libraries:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"http://jquery.com/",children:"jQuery"})}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/wikimedia/jquery.i18n",children:"Wikimedia's jQuery.i18n"}),"\nThe front-end dependencies are fetched at build time via ",(0,i.jsx)(t.a,{href:"https://www.npmjs.com/",children:"NPM"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The server-side part of OpenRefine relies on many libraries, for instance to implement import and export in many different formats.\nThose are fetched at build time via ",(0,i.jsx)(t.a,{href:"https://maven.apache.org/",children:"Apache Maven"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The data storage and processing architecture is being transformed. Up to version 3.x, OpenRefine uses an in-memory storage, where the entire project grid is loaded in the Java heap, with operations mutating that state. From 4.x on, OpenRefine uses a\ndifferent architecture, where data is stored on disk by default and cached in memory if the project is small enough."}),"\n",(0,i.jsx)(t.h2,{id:"server-side-architecture",children:"Server-side architecture"}),"\n",(0,i.jsxs)(t.p,{children:["OpenRefine's server-side is written entirely in Java (",(0,i.jsx)(t.code,{children:"main/src/"}),") and its entry point is the Java servlet ",(0,i.jsx)(t.code,{children:"com.google.refine.RefineServlet"}),". By default, the servlet is hosted in the lightweight Jetty web server instantiated by ",(0,i.jsx)(t.code,{children:"server/src/com.google.refine.Refine"}),". Note that the server class itself is under ",(0,i.jsx)(t.code,{children:"server/src/"}),", not ",(0,i.jsx)(t.code,{children:"main/src/"}),"; this separation leaves the possibility of hosting ",(0,i.jsx)(t.code,{children:"RefineServlet"})," in a different servlet container."]}),"\n",(0,i.jsxs)(t.p,{children:["The web server configuration is in ",(0,i.jsx)(t.code,{children:"main/webapp/WEB-INF/web.xml"}),"; that's where ",(0,i.jsx)(t.code,{children:"RefineServlet"})," is hooked up. ",(0,i.jsx)(t.code,{children:"RefineServlet"})," itself is simple: it just reacts to requests from the client-side by routing them to the right ",(0,i.jsx)(t.code,{children:"Command"})," class in the packages ",(0,i.jsx)(t.code,{children:"com.google.refine.commands.**"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["As mentioned before, the server-side maintains states of the data, and the primary class involved is ",(0,i.jsx)(t.code,{children:"com.google.refine.ProjectManager"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"projects",children:"Projects"}),"\n",(0,i.jsxs)(t.p,{children:["In OpenRefine there's the concept of a workspace similar to that in ",(0,i.jsx)(t.a,{href:"https://www.eclipse.org/ide",children:"Eclipse IDE"}),". When you run OpenRefine it manages projects within a single workspace, and the workspace is organized in a file directory with sub-directories. The default workspace directories are listed ",(0,i.jsx)(t.a,{href:"/docs/manual/installing#set-where-data-is-stored",children:"in the manual"})," and it also explains how to change them."]}),"\n",(0,i.jsxs)(t.p,{children:["The class ",(0,i.jsx)(t.code,{children:"ProjectManager"})," is what manages the workspace. It keeps in memory the metadata of every project (in the class ",(0,i.jsx)(t.code,{children:"ProjectMetadata"}),"). This metadata includes the project's name and last modified date, and any other information necessary to present and let the user interact with the project as a whole. Only when the user decides to look at the project's data would ",(0,i.jsx)(t.code,{children:"ProjectManager"})," load the project's actual data. The separation of project metadata and data is to minimize the amount of stuff loaded into memory."]}),"\n",(0,i.jsxs)(t.p,{children:["A project's ",(0,i.jsx)(t.em,{children:"actual"})," data includes the columns, rows, cells, reconciliation records, and history entries."]}),"\n",(0,i.jsx)(t.p,{children:"A project is loaded when it needs to be displayed or modified, and it remains in memory until 1 hour after the last time it gets modified. Periodically the project manager tries to save modified projects, and it saves as many modified projects as possible within 30 seconds."}),"\n",(0,i.jsx)(t.h3,{id:"data-model",children:"Data Model"}),"\n",(0,i.jsx)(t.p,{children:"A project's data consists of"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"raw data"}),": a list of rows, each row consisting of a list of cells"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"models"})," on top of that raw data that give high-level presentation or interpretation of that data. This design lets the same raw data be viewed in different ways by different models, and let the models be changed without costly changes to the raw data."]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"column-model",children:"Column Model"}),"\n",(0,i.jsxs)(t.p,{children:["Cells in rows are not named and can only be addressed by their list position indices. So, a ",(0,i.jsx)(t.em,{children:"column model"})," is needed to give a name to each list position. The column model also stores other metadata for each column, including the type that cells in the column have been reconciled to and the overall reconciliation statistics of those cells."]}),"\n",(0,i.jsx)(t.p,{children:"Each column also acts as a cache for data computed from the raw data related to that column."}),"\n",(0,i.jsx)(t.p,{children:"Columns in the column model can be removed and re-ordered without changing the raw data--the cells in the rows. This makes column removal and ordering operations really quick."}),"\n",(0,i.jsx)(t.h5,{id:"column-groups",children:"Column Groups"}),"\n",(0,i.jsxs)(t.admonition,{type:"caution",children:[(0,i.jsx)(t.p,{children:"This feature is partially implemented, buggy and deprecated. It will be removed in OpenRefine 4.0.\nSee the following links for details:"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://github.com/OpenRefine/OpenRefine/issues/5122",children:"Issue#5122"})," that first argues it's a useful feature, but then agrees with its deprecation"]}),"\n",(0,i.jsxs)(t.li,{children:["Discussion ",(0,i.jsx)(t.a,{href:"https://groups.google.com/g/openrefine/c/A8RhOwlulRs/m/NFR8LDBmBwAJ",children:"Who uses column groups?"})]}),"\n",(0,i.jsxs)(t.li,{children:["Discussion ",(0,i.jsx)(t.a,{href:"https://groups.google.com/g/openrefine/c/X9O8NBC1UKQ",children:"The future of the records mode"})," about better ways of implementing grouping and a hierarchical model in OpenRefine."]}),"\n"]}),(0,i.jsxs)(t.p,{children:["This feature is related to ",(0,i.jsx)(t.a,{href:"../manual/exploring#rows-vs-records",children:"Rows vs Records"}),", which however continues to be supported."]})]}),"\n",(0,i.jsx)(t.p,{children:"Consider the following data:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://raw.github.com/OpenRefine/OpenRefine/2.0/graphics/row-groups.png",alt:"Illustration of row groups in OpenRefine"})}),"\n",(0,i.jsx)(t.p,{children:'Although the data is in a grid, we humans can understand that it is a tree. First of all, all rows contain data ultimately linked to the movie Austin Powers, although only one row contains the text "Austin Powers" in the "movie title" column. We also know that "USA" and "Germany" are not related to Elizabeth Hurley and Mike Myers respectively (say, as their nationality), but rather, "USA" and "Germany" are related to the movie (where it was released). We know that Mike Myers played both the character "Austin Powers" and the character "Dr. Evil"; and for the latter he received 2 awards. We humans can understand how to interpret the grid as a tree based on its visual layout as well as some knowledge we have about the movie domain but is not encoded in the table.'}),"\n",(0,i.jsxs)(t.p,{children:["OpenRefine can capture our knowledge of this transformation from grid to tree using ",(0,i.jsx)(t.em,{children:"column groups"}),", also stored in the column model. Each column group illustrated as a blue bracket above specifies which columns are grouped together, as well as which of those columns is the key column in that group (blue triangle). One column group can span over columns grouped by another column group, and in this way, column groups form a hierarchy determined by which column group envelopes another. This hierarchy of column groups allows the 2-dimensional (grid-shaped) table of rows and cells to be interpreted as a list of hierarchical (tree-shaped) data records."]}),"\n",(0,i.jsxs)(t.p,{children:['Blank cells play a very important role. The blank cell in a key column of a row (e.g., cell "character" on row 4) makes that row (row 4) ',(0,i.jsx)(t.em,{children:"depend"}),' on the first preceding row with that column filled in (row 3). This means that "Best Comedy Perf" on row 4 applies to "Dr. Evil" on row 3. Row 3 is said to be a ',(0,i.jsx)(t.em,{children:"context row"})," for row 4. Similarly, since rows 2 - 6 all have blank cells in the first column, they all depend on row 1, and all their data ultimately applies to the movie Austin Powers. Row 1 depends on no other row and is said to be a ",(0,i.jsx)(t.em,{children:"record row"}),". Rows 1 - 6 together form one ",(0,i.jsx)(t.em,{children:"record"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Currently (as of 12th December 2017) only the XML and JSON importers create column groups, and while the data table view does display column groups but it doesn't support modifying them."}),"\n",(0,i.jsx)(t.h3,{id:"changes-history-processes-and-operations",children:"Changes, History, Processes, and Operations"}),"\n",(0,i.jsx)(t.p,{children:"All changes to the project's data are tracked (N.B. this does not include changes to a project's metadata - such as the project name.)"}),"\n",(0,i.jsxs)(t.p,{children:["Changes are stored as ",(0,i.jsx)(t.code,{children:"com.google.refine.history.Change"})," objects. ",(0,i.jsx)(t.code,{children:"com.google.refine.history.Change"})," is an interface, and implementing classes are in ",(0,i.jsx)(t.code,{children:"com.google.refine.model.changes.**"}),". Each change object stores enough data to modify the project's data when its ",(0,i.jsx)(t.code,{children:"apply()"})," method is called, and enough data to revert its effect when its ",(0,i.jsx)(t.code,{children:"revert()"})," method is called. It's only supposed to ",(0,i.jsx)(t.em,{children:"store"})," data, not to actually ",(0,i.jsx)(t.em,{children:"compute"})," the change. In this way, it's like a .diff patch file for a code base."]}),"\n",(0,i.jsxs)(t.p,{children:["Some change objects can be huge, as huge as the project itself. So change objects are not kept in memory except when they are to be applied or reverted. However, since we still need to show the user some information about changes (as displayed in the History panel in the UI), we keep metadata of changes separate from the change objects. For each change object there is one corresponding ",(0,i.jsx)(t.code,{children:"com.google.refine.history.HistoryEntry"})," for storing its metadata, such as the change's human-friendly description and timestamp."]}),"\n",(0,i.jsxs)(t.p,{children:["Each project has a ",(0,i.jsx)(t.code,{children:"com.google.refine.history.History"})," object that contains an ordered list of all ",(0,i.jsx)(t.code,{children:"HistoryEntry"})," objects storing metadata for all changes that have been done since after the project was created. Actually, there are 2 ordered lists: one for done changes that can be reverted (undone), an done for undone changes that can be re-applied (redone). Changes must be done or redone in their exact orders in these lists because each change makes certain assumptions about the state of the project before and after it is applied. As changes cannot be undone/redone out of order, when one change fails to revert, it blocks the whole history from being reverted to any state preceding that change (as happened in ",(0,i.jsx)(t.a,{href:"https://github.com/OpenRefine/OpenRefine/issues/2",children:"Issue #2"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["As mentioned before, a change contains only the diff and does not actually compute that diff. The computation is performed by a ",(0,i.jsx)(t.code,{children:"com.google.refine.process.Process"})," object--every change object is created by a process object. A process can be immediate, producing its change object synchronously within a very short period of time (e.g., starring one row); or a process can be long-running, producing its change object after a long time and a lot of computation, including network calls (e.g., reconciling a column)."]}),"\n",(0,i.jsx)(t.p,{children:"As the user interacts with the UI on the client-side, their interactions trigger ajax calls to the server-side. Some calls are meant to modify the project. Those are handled by commands that instantiates processes. Processes are queued in a first-in-first-out basis. The first-in process gets run and until it is done all the other processes are stuck in the queue."}),"\n",(0,i.jsxs)(t.p,{children:["A process can effect a change in one thing in the project (e.g., edit one particular cell, star one particular row), or a process can effect changes in ",(0,i.jsx)(t.em,{children:"potentially"})," many things in the project (e.g., edit zero or more cells sharing the same content, starring all rows filtered by some facets). The latter kind of process is generalizable: it is meaningful to apply them on another similar project. Such a process is associated with an ",(0,i.jsx)(t.em,{children:"abstract operation"})," ",(0,i.jsx)(t.code,{children:"com.google.refine.model.AbstractOperation"}),' that encodes the information necessary to create another instance of that process, but potentially for a different project. When you click "extract" in the History panel, these abstract operations are called to serialize their information to JSON; and when you click "apply" in the History panel, the JSON you paste in is used to re-construct these abstract operations, which in turn create processes, which get run sequentially in a queue to generate change object and history entry pairs.']}),"\n",(0,i.jsx)(t.p,{children:"In summary,"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"change objects store diffs"}),"\n",(0,i.jsx)(t.li,{children:"history entries store metadata of change objects"}),"\n",(0,i.jsx)(t.li,{children:"processes compute diffs and create change object and history entry pairs"}),"\n",(0,i.jsx)(t.li,{children:"some processes are long-running and some are immediate; processes are run sequentially in a queue"}),"\n",(0,i.jsx)(t.li,{children:"generalizable processes can be re-constructed from abstract operations"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"client-side-architecture",children:"Client-side architecture"}),"\n",(0,i.jsx)(t.p,{children:"The client-side part of OpenRefine is implemented in HTML, CSS and Javascript and uses the following Javascript libraries:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"http://jquery.com/",children:"jQuery"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"http:jqueryui.com/",children:"jQueryUI"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://github.com/recurser/jquery-i18n",children:"Recurser jquery-i18n"})}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"importing-architecture",children:"Importing architecture"}),"\n",(0,i.jsx)(t.p,{children:"OpenRefine has a sophisticated architecture for accommodating a diverse and extensible set of importable file formats and workflows. The formats range from simple CSV, TSV to fixed-width fields to line-based records to hierarchical XML and JSON. The workflows allow the user to preview and tweak many different import settings before creating the project. In some cases, such as XML and JSON, the user also has to select which elements in the data file to import. Additionally, a data file can also be an archive file (e.g., .zip) that contains many files inside; the user can select which of those files to import. Finally, extensions to OpenRefine can inject functionalities into any part of this architecture."}),"\n",(0,i.jsx)(t.h3,{id:"the-index-page-and-action-areas",children:"The Index Page and Action Areas"}),"\n",(0,i.jsxs)(t.p,{children:["The opening screen of OpenRefine is implemented by the file ",(0,i.jsx)(t.code,{children:"main/webapp/modules/core/index.vt"}),' and will be referred to here as the index page. Its default implementation contains 3 finger tabs labeled Create Project, Open Project, and Import Project. Each tab selects an "action area". The 3 default action areas are for, obviously, creating a new project, opening an existing project, and importing a project .tar file.']}),"\n",(0,i.jsxs)(t.p,{children:["Extensions can add more action areas in Javascript. For example, this is how the Create Project action area is added (",(0,i.jsx)(t.code,{children:"main/webapp/modules/core/scripts/index/create-project-ui.js"}),"):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'Refine.actionAreas.push({\n  id: "create-project",\n  label: "Create Project",\n  uiClass: Refine.CreateProjectUI\n});\n'})}),"\n",(0,i.jsx)(t.p,{children:"The UI class is a constructor function that takes one argument, a jQuery-wrapped HTML element where the tab body of the action area should be rendered."}),"\n",(0,i.jsx)(t.p,{children:"If your extension requires a very unique importing work flow, or a very novel feature that should be exposed on the index page, then add a new action area. Otherwise, try to use the existing work flows as much as possible."}),"\n",(0,i.jsx)(t.h3,{id:"the-create-project-action-area",children:"The Create Project Action Area"}),"\n",(0,i.jsx)(t.p,{children:'The Create Project action area is itself extensible. Initially, it embeds a set of finger tabs corresponding to a variety of "source selection UIs": you can select a source of data by specifying a file on your computer, or you can specify the URL to a publicly accessible data file or data feed, or you can paste in from the clipboard a chunk of data.'}),"\n",(0,i.jsx)(t.p,{children:"There are actually 3 points of extension in the Create Project action area, and the first is invisible."}),"\n",(0,i.jsx)(t.h4,{id:"importing-controllers",children:"Importing Controllers"}),"\n",(0,i.jsx)(t.p,{children:'The Create Project action area manages a list of "importing controllers". Each controller follows a particular work flow (in UI terms, think "wizard"). Refine comes with a "default importing controller" (refine/main/webapp/modules/core/scripts/index/default-importing-controller/controller.js) and its work flow assumes that the data can be retrieved and cached in whole before getting processed in order to generate a preview for the user to inspect. (If the data cannot be retrieved and cached in whole before previewing, then another importing controller is needed.)'}),"\n",(0,i.jsx)(t.p,{children:"An importing controller is just programming logic, but it can manifest itself visually by registering one or more data source UIs and one or more custom panels in the Create Project action area. The default importing controller registers 3 such custom panels, which act like pages of a wizard."}),"\n",(0,i.jsxs)(t.p,{children:["An extension can register any number of importing controller. Each controller has a client-side part and a server-side part. Its client-side part is just a constructor function that takes an object representing the Create Project action area (usually named ",(0,i.jsx)(t.code,{children:"createProjectUI"}),"). The controller (client-side) is expected to use that object to register data source UIs and/or create custom panels. The controller is not expected to have any particular interface method. The default importing controller's client-side code looks like this (",(0,i.jsx)(t.code,{children:"main/webapp/modules/core/scripts/index/default-importing-controller/controller.js"}),"):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"Refine.DefaultImportingController = function(createProjectUI) {\n  this._createProjectUI = createProjectUI; // save a reference to the create project action area\n\n  this._progressPanel = createProjectUI.addCustomPanel(); // create a custom panel\n  this._progressPanel.html('...'); // render the custom panel\n  ... do other stuff ...\n};\nRefine.CreateProjectUI.controllers.push(Refine.DefaultImportingController); // register the controller\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We will cover the server-side code ",(0,i.jsx)(t.a,{href:"#importingcontrollers",children:"below"}),"."]}),"\n",(0,i.jsx)(t.h4,{id:"data-source-selection-uis",children:"Data Source Selection UIs"}),"\n",(0,i.jsx)(t.p,{children:"Data source selection UIs are another point of extensibility in the Create Project action area. As mentioned previously, by default there are 3 data source UIs. Those are added by the default importing controller."}),"\n",(0,i.jsx)(t.p,{children:"Extensions can also add their own data source UIs. A data source selection UI object can be registered like so"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'createProjectUI.addSourceSelectionUI({\n  label: "This Computer",\n  id: "local-computer-source",\n  ui: theDataSourceSelectionUIObject\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"theDataSourceSelectionUIObject"})," is an object that has the following member methods:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"attachUI(bodyDiv)"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"focus()"})}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["If you want to install a data source selection UI that is managed by the default importing controller, then register its UI class with the default importing controller, like so (",(0,i.jsx)(t.code,{children:"main/webapp/modules/core/scripts/index/default-importing-sources/sources.js"}),"):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'Refine.DefaultImportingController.sources.push({\n    "label": "This Computer",\n    "id": "upload",\n    "uiClass": ThisComputerImportingSourceUI\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The default importing controller will assume that the ",(0,i.jsx)(t.code,{children:"uiClass"})," field is a constructor function and call it with one argument--the controller object itself. That constructor function should save the controller object for later use. More specifically, for data source UIs that use the default importing controller, they can call the controller to kickstart the process that retrieves and caches the data to import:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:'controller.startImportJob(form, "... status message ...");\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The argument ",(0,i.jsx)(t.code,{children:"form"})," is a jQuery-wrapped FORM element that will get submitted to the server side at the command ",(0,i.jsx)(t.code,{children:"/command/core/create-importing-job"}),". That command and the default importing controller will take care of uploading or downloading the data, caching it, updating the client side's progress display, and then showing the next importing step when the data is fully cached."]}),"\n",(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.code,{children:"main/webapp/modules/core/scripts/index/default-importing-sources/sources.js"})," for examples of such source selection UIs. While we write about source selection UIs managed by the default importing controller here, chances are your own extension will not be adding such a new source selection UI. Your extension probably adds with a new importing controller as well as a new source selection UI that work together."]}),"\n",(0,i.jsx)(t.h4,{id:"file-selection-panel",children:"File Selection Panel"}),"\n",(0,i.jsx)(t.p,{children:"This screen is shown when there are multiple files to choose from when creating a project, for instance after uploading a zip file with multiple files in it. This interface lets the user choose which files to import to create a new project.\nAlthough OpenRefine only supports one table per project so far, it is possible to select multiple files to import. Their contents will be concatenated into a single table."}),"\n",(0,i.jsx)(t.h4,{id:"parsing-ui-panel",children:"Parsing UI Panel"}),"\n",(0,i.jsxs)(t.p,{children:["The parsing UI panel is shown when importing data into a new project.\nPrimarily, it lets the user select in which format the data is, which determines how it is read and transformed into an OpenRefine project. The back-end will try to supply an informed guess for the format using the ",(0,i.jsx)(t.a,{href:"#formatguesser",children:"format guesser"}),", but it\nis not uncommon that this initial choice must be overriden by the user."]}),"\n",(0,i.jsxs)(t.p,{children:['Beyond this choice of format, the parsing UI panel offers a configuration panel for the chosen importer. This part of the UI can be defined independently for each input format, given that not all options are relevant for all formats. For instance, when\nselecting the "Text file" option, the specific UI of the ',(0,i.jsx)(t.code,{children:"LinedBasedImporter"})," will be shown. This UI is defined in:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"main/webapp/modules/core/scripts/index/parser-interfaces/line-based-parser-ui.html"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.code,{children:"main/webapp/modules/core/scripts/index/parser-interfaces/line-based-parser-ui.js"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Other importers generally define their own parsing configuration panel as well."}),"\n",(0,i.jsxs)(t.p,{children:["The link between the format's identifier (MIME type), importer (Java class which defines the parsing logic) and parsing options UI (Javascript class that defines the rendering of this options area) is made in the ",(0,i.jsx)(t.code,{children:"main/webapp/modules/core/MOD-INF/controller.js"})," file,\nwhere those components are registered together in the ",(0,i.jsx)(t.code,{children:"ImportingManager"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"server-side-components",children:"Server-side Components"}),"\n",(0,i.jsx)(t.h4,{id:"importingcontroller",children:"ImportingController"}),"\n",(0,i.jsxs)(t.p,{children:["An importing controller is a component of the back-end which is in charge of the entire importing workflow, from the initial transfer of the raw data to be imported to the created project, with all the configuration steps in between, ",(0,i.jsx)(t.a,{href:"#importing-controllers",children:"as described in the\nearlier section"}),". OpenRefine comes with\na default importing controller which implements this for data coming from:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"file upload by the user via the web interface"}),"\n",(0,i.jsx)(t.li,{children:"upload of textual information using the clipboard import form"}),"\n",(0,i.jsx)(t.li,{children:"download of a file by supplying a URL"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For all of these data sources, the first step consists of storing the corresponding input files in a temporary directory inside the workspace. The default importing controller provides an HTTP API used by the front-end to select which files to import, ",(0,i.jsx)(t.a,{href:"#formatguesser",children:"predict\nthe format they are in"}),", provide default importing options for the selected format, preview the project's first few rows with the given options, and finally create the project."]}),"\n",(0,i.jsx)(t.p,{children:"The importing controller is not used for loading existing projects or importing OpenRefine project archives: the project manager is responsible for both of those."}),"\n",(0,i.jsxs)(t.p,{children:["Extensions can define other importing controllers to implement other importing flows depending on the data source. For instance, importing data from a SQL database requires different steps such as selecting the database and providing a SQL query. The\n",(0,i.jsx)(t.code,{children:"database"})," extension implements such a workflow by providing its own importing controller."]}),"\n",(0,i.jsx)(t.h4,{id:"formatguesser",children:"FormatGuesser"}),"\n",(0,i.jsxs)(t.p,{children:["A format guesser is a class that tries to determine the MIME type of a file, considering its contents.\nThe ",(0,i.jsx)(t.code,{children:"FormatGuesser"})," interface has multiple implementations, which can be used to determine the format depending on its basic type (binary, text based).\nFor text files, this relies on heuristics which are quite ad-hoc and brittle. For binary files, we do not currently try to do anything, while one would at least expect that we check for some so-called magic numbers at the beginning of files, which can be\nused to detect many file formats."]}),"\n",(0,i.jsx)(t.p,{children:"Worse, our format guessing logic does not actually attempt to parse the files with the guessed formats, so it is not uncommon that the user is directly presented with a parsing error (in the form of a javascript alert) upon importing files."}),"\n",(0,i.jsx)(t.p,{children:"This could be avoided by trying to read the given files with the predicted importer before suggesting the format to the user, making sure that at least that does not throw an exception."}),"\n",(0,i.jsx)(t.h4,{id:"importingparser",children:"ImportingParser"}),"\n",(0,i.jsxs)(t.p,{children:["An ",(0,i.jsx)(t.code,{children:"ImportingParser"})," is a class that is responsible for parsing a file into OpenRefine's project model.\nIt takes a range of importing options passed on from the frontend, input by the user into a dedicated UI, specific to the format being parsed."]}),"\n",(0,i.jsx)(t.p,{children:"When possible, parsers are designed so that they can import the first few rows of the project without reading the entire input file in memory. This helps provide fast previews of the project to be created when the user changes importing options. Every\nchange in the importing options triggers a new parse of the source files (unless the user has disabled auto preview option in the parsing configuration panel)."}),"\n",(0,i.jsx)(t.h2,{id:"faceted-browsing-architecture",children:"Faceted browsing architecture"}),"\n",(0,i.jsxs)(t.p,{children:["Faceted browsing support is core to OpenRefine as it is the primary and only mechanism for filtering to a subset of rows on which to do something ",(0,i.jsx)(t.em,{children:"en masse"})," (ie in bulk). Without faceted browsing or an equivalent querying/browsing mechanism, you can only change one thing at a time (one cell or row) or else change everything all at once; both kinds of editing are practically useless when dealing with large data sets."]}),"\n",(0,i.jsx)(t.p,{children:"In OpenRefine, different components of the code need to know which rows to process from the faceted browsing state (how the facets are constrained). For example, when the user applies some facet selections and then exports the data, the exporter serializes only the matching rows, not all rows in the project. Thus, faceted browsing isn't only hooked up to the data view for displaying data to the user, but it is also hooked up to almost all other parts of the system."}),"\n",(0,i.jsx)(t.h3,{id:"engine-configuration",children:"Engine Configuration"}),"\n",(0,i.jsxs)(t.p,{children:["As OpenRefine is a web app, there might be several browser windows opened on the same project, each in a different faceted browsing state. It is best to maintain the faceted browsing state in each browser window while keeping the server side completely stateless with regard to faceted browsing. Whenever the client-side needs something done by the server, it transfers the entire faceted browsing state over to the server-side. The faceted browsing state behaves much like the ",(0,i.jsx)(t.code,{children:"WHERE"})," clause in a SQL query, telling the server-side how to select the rows to process."]}),"\n",(0,i.jsx)(t.p,{children:'In fact, it is best to think of the faceted browsing state as just a database query much like a SQL query. It can be passed around the whole system, to any component needing to know which rows to process. It is serialized into JSON to pass between the client-side and the server side, or to save in an abstract operation\'s specification. The job of the faceted browsing subsystem on the client-side is to let the user interactively modify this "faceted browsing query", and the job of the faceted browsing subsystem on the server side is to resolve that query.'}),"\n",(0,i.jsxs)(t.p,{children:["In the code, the faceted browsing state, or faceted browsing query, is actually called the ",(0,i.jsx)(t.em,{children:"engine configuration"})," or ",(0,i.jsx)(t.em,{children:"engine config"}),' for short. It consists mostly of an array facet configurations. For each facet, it stores the name of the column on which the facet is based (or an empty string if there is no base column). Each type of facet has different configuration. Text search facets have queries and flags for case-sensitivity mode and regular expression mode. Text facets (aka list facets) and numeric range facets have expressions. Each list facet also has an array of selected choices, an invert flag, and flags for whether blank and error cells are selected. Each numeric range facet has, among other things, a "from" and a "to" values. If you trace the AJAX calls, you\'d see the engine configs being shuttled, e.g.,']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-json",children:'{\n    "mode": "rows",\n    "facets" : [\n      {\n        "type": "text",\n        "name": "Shrt_Desc",\n        "columnName": "Shrt_Desc",\n        "mode": "text",\n        "caseSensitive": false,\n        "query": "cheese"\n      },\n      {\n        "type": "list",\n        "name": "Shrt_Desc",\n        "columnName": "Shrt_Desc",\n        "expression": "grel:value.toLowercase().split(\\",\\")",\n        "omitBlank": false,\n        "omitError": false,\n        "selection": [],\n        "selectBlank":false,\n        "selectError":false,\n        "invert":false\n      },\n      {\n        "type": "range",\n        "name": "Water",\n        "expression": "value",\n        "columnName": "Water",\n        "selectNumeric": true,\n        "selectNonNumeric": true,\n        "selectBlank": true,\n        "selectError": true,\n        "from": 0,\n        "to": 53\n      }\n    ]\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"server-side-subsystem",children:"Server-Side Subsystem"}),"\n",(0,i.jsx)(t.p,{children:"From an engine configuration like the one above, the server-side faceted browsing subsystem is capable of producing:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"an iteration over the rows matching the facets' constraints"}),"\n",(0,i.jsx)(t.li,{children:"information on how to render the facets (e.g., choice and count pairs for a list facet, histogram for a numeric range facet)"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["When the engine config JSON arrives in an HTTP request on the server-side, a ",(0,i.jsx)(t.code,{children:"com.google.refine.browsing.Engine"})," object is constructed and initialized with that JSON. It in turns constructs zero or more ",(0,i.jsx)(t.code,{children:"com.google.refine.browsing.facets.Facet"})," objects. Then for each facet, the engine calls its ",(0,i.jsx)(t.code,{children:"getRowFilter()"})," method, which returns ",(0,i.jsx)(t.code,{children:"null"})," if the facet isn't constrained in anyway, or a ",(0,i.jsx)(t.code,{children:"com.google.refine.browsing.filters.RowFilter"})," object. Then, to when iterating over a project's rows, the engine calls on all row filters' ",(0,i.jsx)(t.code,{children:"filterRow()"})," method. If and only if all row filters return ",(0,i.jsx)(t.code,{children:"true"})," the row is considered to match the facets' constraints. How each row filter works depends on the corresponding type of facet."]}),"\n",(0,i.jsxs)(t.p,{children:["To produce information on how to render a particular facet in the UI, the engine follows the same procedure described in the previous except it skips over the facet in question. In other words, it produces an iteration over all rows constrained by the other facets. Then it feeds that iteration to the facet in question by calling the facet's ",(0,i.jsx)(t.code,{children:"computeChoices()"})," method. This gives the method a chance to compute the rendering information for its UI counterpart on the client-side. When all facets have been given a chance to compute their rendering information, the engine calls all facets to serialize their information as JSON and returns the JSON to the client-side. Only one HTTP call is needed to compute all facets."]}),"\n",(0,i.jsx)(t.h3,{id:"client-side-subsystem",children:"Client-side subsystem"}),"\n",(0,i.jsx)(t.p,{children:"On the client-side there is also an engine object (implemented in Javascript rather than Java) and zero or more facet objects (also in Javascript, obviously). The engine is responsible for distributing the rendering information computed on the server-side to the right facets, and when the user interacts with a facet, the facet tells the engine to update the whole UI. To do so, the engine gathers the configuration of each facet and composes the whole engine config as a single JSON object. Two separate AJAX calls are made with that engine config, one to retrieve the rows to render, and one to re-compute the rendering information for the facets because changing one facet does affect all the other facets."})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},69018:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>o});var i=n(47768);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);