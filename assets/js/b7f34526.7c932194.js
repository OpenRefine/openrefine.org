"use strict";(self.webpackChunkOpenRefine_Documentation=self.webpackChunkOpenRefine_Documentation||[]).push([[1923],{41610:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=n(64861),o=n(69018);const s={id:"reconciliation-api",title:"Reconciliation API",sidebar_label:"Reconciliation API"},r=void 0,c={id:"technical-reference/reconciliation-api",title:"Reconciliation API",description:"This is a technical description of the mechanisms behind the reconciliation system in OpenRefine. For usage instructions, see Reconciliation.",source:"@site/docs/technical-reference/reconciliation-api.md",sourceDirName:"technical-reference",slug:"/technical-reference/reconciliation-api",permalink:"/docs/technical-reference/reconciliation-api",draft:!1,unlisted:!1,editUrl:"https://github.com/OpenRefine/openrefine.github.com/edit/master/docs/technical-reference/reconciliation-api.md",tags:[],version:"current",lastUpdatedBy:"Antonin Delpeuch",lastUpdatedAt:1680701589e3,frontMatter:{id:"reconciliation-api",title:"Reconciliation API",sidebar_label:"Reconciliation API"},sidebar:"docs",previous:{title:"OpenRefine API",permalink:"/docs/technical-reference/openrefine-api"},next:{title:"Writing extensions",permalink:"/docs/technical-reference/writing-extensions"}},a={},l=[{value:"API versions supported by OpenRefine",id:"api-versions-supported-by-openrefine",level:2},{value:"Create a new reconciliation service",id:"create-a-new-reconciliation-service",level:2}];function h(e){const i={a:"a",em:"em",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:(0,t.jsxs)(i.em,{children:["This is a technical description of the mechanisms behind the reconciliation system in OpenRefine. For usage instructions, see ",(0,t.jsx)(i.a,{href:"/docs/manual/reconciling",children:"Reconciliation"}),"."]})}),"\n",(0,t.jsx)(i.p,{children:"A reconciliation service is a web service that, given some text which is a name or label for something, and optionally some additional details, returns a ranked list of potential entities matching the criteria. The candidate text does not have to match each entity's official name perfectly, and that's the whole point of reconciliation--to get from ambiguous text name to precisely identified entities. For instance, given the text \"apple\", a reconciliation service probably should return the fruit apple, the Apple Inc. company, and New York city (also known as the Big Apple)."}),"\n",(0,t.jsxs)(i.p,{children:['Entities are identified by strong identifiers in some particular identifier space. In the same identifier space, identifiers follow the same syntax. For example, given the string "apple", a reconciliation service might return entities identified by the strings " ',(0,t.jsx)(i.a,{href:"https://www.wikidata.org/wiki/Q89",children:"Q89"}),'", "',(0,t.jsx)(i.a,{href:"https://www.wikidata.org/wiki/Q312",children:"Q312"}),'", and "',(0,t.jsx)(i.a,{href:"https://www.wikidata.org/wiki/Q60",children:"Q60"}),'", in the Wikidata ID space. Each reconciliation service can only reconcile to one single identifier space, but several reconciliation services can reconcile to the same identifier space.']}),"\n",(0,t.jsxs)(i.p,{children:["OpenRefine can connect to any reconciliation service which follows the ",(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/specs/0.2/",children:"reconciliation API v0.2"}),". This was formerly a specification edited by the OpenRefine project, which has now transitioned to its own\n",(0,t.jsx)(i.a,{href:"https://www.w3.org/community/reconciliation/",children:"W3C Entity Reconciliation Community Group"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Informally, the main function of any reconciliation service is to find good candidates in the underlying database, given the following data:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"A string, which is normally the name or title of the entity, in some language."}),"\n",(0,t.jsx)(i.li,{children:"Optionally, a type which can be used to narrow down the search to entities of this type. OpenRefine does not define a particular set of acceptable types: this choice is left to the reconciliation service (see the suggest API for that)."}),"\n",(0,t.jsx)(i.li,{children:"Optionally, a list of properties and their values, which can be used to refine the search. For instance, when reconciling a database of books, the author name or the publication date are useful bits of information that can be transferred to the reconciliation service. This information will be sent to the reconciliation service if the user binds columns to properties. Again, the notion of property is not predefined in OpenRefine: its definition depends on the reconciliation service."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"In a sense, the reconciliation protocol is a standardized search API tailored to the specific needs of data matching. Beyond searching for candidate matches, it also comes with other features to help the user review and correct a matching (by offering previews and auto-completion for the target dataset)."}),"\n",(0,t.jsxs)(i.p,{children:["See ",(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/specs/0.1",children:"the specifications of the protocol"})," for more details about it. You can suggest changes on its ",(0,t.jsx)(i.a,{href:"https://github.com/reconciliation-api/specs/issues",children:"issues tracker"})," or on the ",(0,t.jsx)(i.a,{href:"https://lists.w3.org/Archives/Public/public-reconciliation/",children:"group mailing\nlist"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"api-versions-supported-by-openrefine",children:"API versions supported by OpenRefine"}),"\n",(0,t.jsx)(i.p,{children:"There are multiple versions of the protocol available:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"https://www.w3.org/community/reports/reconciliation/CG-FINAL-specs-0.1-20230321/",children:"version 0.1"}),", supported since OpenRefine 2.7. This version of the protocol is based on ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/JSONP#Security_concerns",children:"JSONP"}),", which represents a security risk. Therefore we discourage services to implement this version of the specifications."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/specs/0.2/",children:"version 0.2"}),", supported since OpenRefine 3.3. This is the current stable version of the protocol, which we encourage services to implement."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/specs/draft/",children:"the current draft of the next version"}),", which is not supported by OpenRefine yet."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"create-a-new-reconciliation-service",children:"Create a new reconciliation service"}),"\n",(0,t.jsx)(i.p,{children:"If you want to create a reconciliation service for a new data source, we have resources to help you.\nYou can work from the specification and implement the API in your own service, but there are also other options."}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["you can reuse an ",(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/census/libraries/",children:"existing library or framework to expose the required web API"}),". Note that it is worth paying attention to which version of the specification they implement."]}),"\n",(0,t.jsxs)(i.li,{children:["you can also use a ",(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/census/services/",children:"standalone tool to expose a reconciliation service on top of a dataset"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["In any case, you can use the ",(0,t.jsx)(i.a,{href:"https://reconciliation-api.github.io/testbench/",children:"reconciliation test bench"})," to test your service interactively on some examples and validate its behaviour. Note that this page also features a list of known public reconciliation services: you could also add yours there if it is hosted publicly."]})]})}function p(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},69018:(e,i,n)=>{n.d(i,{Z:()=>c,a:()=>r});var t=n(47768);const o={},s=t.createContext(o);function r(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);